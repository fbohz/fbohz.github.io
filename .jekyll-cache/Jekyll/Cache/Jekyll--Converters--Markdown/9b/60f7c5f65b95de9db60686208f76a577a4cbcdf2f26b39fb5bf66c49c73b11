I"Ž,<blockquote>
  <p>This is a quick React refresher on the basicsâ€¦If youâ€™re new to React this should get you started on a conceptual realm.</p>
</blockquote>

<h1 id="react-5-minute-refresher">React 5 Minute Refresher</h1>

<p>This is a quick React refresher on the basics, <strong>recommended to those with experience in React</strong>. If youâ€™re new to React this should get you started on a conceptual realm.</p>

<h2 id="react-brief-history">React Brief History</h2>

<ul>
  <li>Back in the day website had sincronous ask from backend what it needed.</li>
  <li>jQuery took care of complexities and also worked in all browsers</li>
  <li>Backbone.js allowed to organize these js files.</li>
  <li>SPA was born out of working more and more with the DOM.
    <ul>
      <li>AJAX downloading all files at once. JS updating as needed.</li>
    </ul>
  </li>
  <li>Angular was born out of this. It had containers that wrap a project. It also had an MVC pattern.
    <ul>
      <li>now there was more complexity. Data flowing everywhere and app maintenance was harder.</li>
    </ul>
  </li>
  <li>2013 React was released by Facebook. 2014 Angular was also rewritten as response.</li>
</ul>

<h2 id="react-core-principles">React Core Principles</h2>

<ul>
  <li>React virtual DOM - Donâ€™t touch the DOM. React will do it.
    <ul>
      <li><em>Imperative Programming</em>: Changing directly the DOM through JS (e.g. getElementById). This approach has that it becomes difficult to point and identify relationships between events.</li>
      <li><em>Declarative Programming</em>: Declares to React what the state or data should look like. React will make the decision of how to implement it. This <code class="highlighter-rouge">state</code> is one big JS object. Resulting in less complexity, faster developer times.</li>
    </ul>
  </li>
  <li>Components.
    <ul>
      <li>Put toguether they form bigger components and form the whole app. You can copy these components and reuse them. Components are built with JSX.</li>
      <li>Reusable components e.g. React.bootstrap, Blueprint etc.</li>
    </ul>
  </li>
  <li><em>Unidirectional</em> Data Flow.
    <ul>
      <li>Anytime we want something to change â€˜stateâ€™ has to change.</li>
      <li>Data flows one way. State changes and trickle down. Data canâ€™t move up.</li>
      <li>This could allow for easier debugging.</li>
      <li>Angular is opposite here.</li>
    </ul>
  </li>
  <li>React is not a framework
    <ul>
      <li>Angular is a framework and gives you everything.</li>
      <li><em>React is a library</em> and lets you use any tools you want from outside.</li>
    </ul>
  </li>
  <li>React Everywhere
    <ul>
      <li>React native</li>
      <li>React desktop, React 360 (VR)</li>
    </ul>
  </li>
</ul>

<h2 id="create-react-app">Create React App</h2>

<ul>
  <li>CLI created so we can build fast React apps.</li>
  <li>npx allows you to build using Create React App without globally installing it first.</li>
  <li>VS code remember to install code in path to open files and folders</li>
  <li><code class="highlighter-rouge">react-scripts</code> does things for us so we donâ€™t worry about webpack nor Babel.</li>
  <li>when we do build on React project, it will take all code inside src and bring it to public folder.</li>
  <li>Babel will make sure that the JS files will work on all browser.</li>
  <li>Webpack is a module bundler. Let us write modular code. It takes all our javascript and optimize it for us.</li>
  <li>React library allows us to write JSX. ReactDOM like the virtual DOM which interacts with the actual DOM.</li>
</ul>

<p><strong>Warning: Ejecting Create React App</strong></p>

<ul>
  <li>You have all scripts for webpack and build, start and test scripts.</li>
  <li>Itâ€™s a lot of code, so not recommended to eject. It is like a lot of competing with developers that work full time on this. They keep up-to-date with industry trends.</li>
</ul>

<h2 id="expanding-react-key-concepts">Expanding React Key Concepts</h2>

<p><strong>React and JSX</strong></p>

<p>JSX has different keywords such as <code class="highlighter-rouge">className</code> instead of regular HTML â€˜classâ€™. Also anything in between <code class="highlighter-rouge">{}</code> is JavaScript injected through JSX.</p>

<p>React always intercepts all events and then we use setState to trigger a <em>re-render</em>, b/c state just got updated.</p>

<p>JSX creates that virtual DOM and then re-renders as state changes.</p>

<p><strong>React Components</strong></p>

<p>You can have react components as classes just as functions. React class components have a <code class="highlighter-rouge">render()</code> method. We use classes to get access to <code class="highlighter-rouge">state</code> and <code class="highlighter-rouge">setState</code> to change state. We build these with <code class="highlighter-rouge">class</code> syntax.</p>

<p>We can also have components that <em>do not</em> extend from <code class="highlighter-rouge">React.Component</code>, we can also get access to state via <em>hooks</em>. We build this with ES6 arrow function syntax. In the past these functional components only received props and returned HTML form JSX.</p>

<p>Our React components act like custome elements that we can mix with common HTML elements but with special powers!</p>

<p>To be able to do special things we get to use the special attribute <code class="highlighter-rouge">props</code> that carry data, functions and eveything to make our application work effectively.</p>

<p>Last thing. You might notice on Class Components could have methods and arrow function declarations inside. A good rule of thumb is this: Use arrow functions on any class methods you define and arenâ€™t part of React (i.e. render(), componentDidMount()).</p>

<p><strong>React Lifecycle Methods (Class Components)</strong></p>

<p>They are methods that get called automatically by React in particular instances of the component life.</p>

<ol>
  <li><code class="highlighter-rouge">constructor()</code>: Called first. Allows the class to have access to lifecycle components. Here is where you declare your state.</li>
  <li><code class="highlighter-rouge">render()</code>: Render is called next to display HTML.</li>
  <li><code class="highlighter-rouge">componentDidMount()</code>: This lifecycle component when component is mounted good when calling fetch requests. This will cause a re-render so <code class="highlighter-rouge">render()</code> gets called again.</li>
  <li><code class="highlighter-rouge">componentDidUpdate</code>: Any updates brings your component to updating phase. React here selectively changes parts of the DOM and it <em>doesnâ€™t remount the component</em>. <code class="highlighter-rouge">componentDidUpdate</code> is called after update. Here you can do additional fetch calls as you compare prev and new props. <a href="https://reactjs.org/docs/react-component.html#componentdidupdate">Read more</a>.</li>
</ol>

<p>Other lifecycle methods:</p>

<ul>
  <li><code class="highlighter-rouge">shouldComponentUpdate()</code>: It checks the props and can decide whether or not update. This is done for optimization read <a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate">here</a> to learn more. You can also consider using React Pure Components, read <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent">here</a>.</li>
  <li><code class="highlighter-rouge">componentWillUnmount()</code>: Called when a component is being removed from the DOM. This is where cleanup can be done, such as memory leaks that JS garbage collection has not picked up. Read <a href="https://reactjs.org/docs/react-component.html#componentwillunmount">docs</a> to learn more.</li>
</ul>

<p>Check out this useful <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">diagram</a> on React lifecycle methods.</p>

<p><strong>Birth of SPAs</strong></p>

<p>Before you used to make requests to the backend youâ€™ll visit one or another page. Now with SPAs although the JS file is bigger, we donâ€™t have to keep coming back to request a new page to the server and just <em>request for data</em> and refresh any part of page we need.</p>

<p>So with SPAs youâ€™ll start talking with APIs to get the data you need. So we build pages dynamically depending on user input.</p>

<p><strong>When do we decide to break a part of our app into a component?</strong></p>

<p>This is key for you to practice and know as a React developer. You should decide this for your self. The idea is that you can reuse this components on other applications and make things more flexible. So you start building your component library. Learn more about component libraries <a href="http://fbohz.com/component_library_storybook">here</a>.</p>

<p><strong>State and Props</strong></p>

<p>When we pass down state, this is usually received as prop by children. This is related to <em>one way data flow</em> of React.</p>

<p>Remember you can also put state wherever you want. Youâ€™ll have to practice how to implement that. Every time state changes there might be implications on re-render and could apply performance. Youâ€™ll start creating a <em>tree of state</em> that changes effect trickle down.</p>

<p>When you work on your tree of state you might want to <em>lift state</em> to parent components so that it can be shared by children.</p>

<p><strong>Synchronous vs Asynchronous</strong></p>

<p>Remember this distinction. Synchronous happens literrally immediately. Async takes time that JavaScript nor React does not know. JS runs the code after it, and then returns when the promise is resolved. React <code class="highlighter-rouge">setState()</code> is async, because React decides for itself when is the best time to run it. In order to see change after when using setState you must use the second argument on its syntax.</p>

<p><strong>Virtual DOM</strong></p>

<p>Remember we donâ€™t directly (impreatively) change the DOM. React takes care of through the virtual DOM. React has what is called <code class="highlighter-rouge">synthetic Event</code>, which it means that React will interfere on all events and decide what to do. React only deals with the real DOM when it sees fit and with its own parameters that is why React feels so fast.</p>

<p>So React takes all the hard work on showing and hiding elements from the DOM for us but we have to learn its mechanism for re-render and how we manage state.</p>

<h2 id="so-how-can-i-be-a-top-react-developer">So how, can I be a top React developer?</h2>

<ul>
  <li><strong>Decide on Components</strong>: What is a component and how you will divide the app.</li>
  <li>Decide on <strong>state and where it lives</strong>.</li>
  <li>Know <strong>what changes when state changes</strong>.</li>
</ul>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://jsonplaceholder.typicode.com/"><strong>JSON Placeholders</strong></a></li>
  <li>Styling with<a href="https://www.youtube.com/watch?v=feYJ5D7VknE&amp;feature=emb_title"> <strong>Styled Components</strong></a>.</li>
  <li><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/"><strong>React lifecycle methods</strong></a>.</li>
  <li><a href="https://www.udemy.com/course/complete-react-developer-zero-to-mastery/"><strong>React course</strong></a>.</li>
</ul>
:ET