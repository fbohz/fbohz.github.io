I"	Y<blockquote>
  <p>We must remember that programs can be defined pretty much as <code class="language-plaintext highlighter-rouge">data structures + algorithms</code>. As we conclude this exploration we’ll be discussing Searching algorithms and Dynamic Programming.</p>
</blockquote>

<h1 id="on-cs-algorithms-chapter-ii">On CS Algorithms: Chapter II</h1>

<p>We must remember that programs can be defined pretty much as <code class="language-plaintext highlighter-rouge">data structures + algorithms</code>. As we conclude this exploration we’ll be discussing Searching algorithms and Dynamic Programming.</p>

<h1 id="searching--traversal-bfs-dfs">Searching + Traversal, BFS, DFS</h1>
<p>We’ll talk about:</p>
<ul>
  <li>Searching + Traversal</li>
  <li>Breadth-first search (BFS), Depth-first search (DFS)</li>
</ul>

<p>Searching is super useful:</p>
<ul>
  <li>We search Google, YouTube, search in file.</li>
  <li>How computers/software can search so fast? Some strategies
    <ul>
      <li>Linear Search</li>
      <li>Binary Search</li>
      <li>BFS</li>
      <li>DFS</li>
    </ul>
  </li>
</ul>

<h2 id="linear--sequential-search">Linear / Sequential Search</h2>

<ul>
  <li>Find target value within a list.</li>
  <li>Like loop through arrays to find items.
    <ul>
      <li>Check one-by-one.</li>
    </ul>
  </li>
  <li>Best case <code class="language-plaintext highlighter-rouge">O(1)</code> and worst case check every single item <code class="language-plaintext highlighter-rouge">O(n)</code></li>
  <li>Some JS strategies using linear:</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">var</span> <span class="nx">beasts</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Centaur</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Godzilla</span><span class="dl">'</span><span class="p">];</span>

<span class="c1">// ALL are linear</span>

<span class="nx">beasts</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="dl">'</span><span class="s1">Godzilla</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">beasts</span><span class="p">.</span><span class="nx">findIndex</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">){</span>
<span class="k">return</span> <span class="nx">item</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">Godzilla</span><span class="dl">'</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// return item instead of index</span>
<span class="nx">beasts</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">){</span>
<span class="k">return</span> <span class="nx">item</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">Godzilla</span><span class="dl">'</span><span class="p">;</span>
<span class="p">})</span>

<span class="c1">// true / false</span>
<span class="nx">beasts</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">Godzilla</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div>

<p>We can’t use this on Google or Facebook, since it will cost time.</p>

<h2 id="binary-search">Binary Search</h2>
<p><strong>Good on sorted lists</strong>. E.g. you’re looking for 34 and list is sorted: 1, 4, 5, 9, 34, 45</p>

<p>Instead of checking everything you can do binary search:</p>
<ul>
  <li>You can start in middle of list:
    <ul>
      <li>Is 9 higher than 34? NO. <strong>Then discard to left</strong>.</li>
      <li>Go to middle of group again and do comparison.</li>
    </ul>
  </li>
  <li>If it’s sorted we can do better than O(n), creating a <strong>binary search tree</strong>. Data complexity since its a tree then it gives great storage too.</li>
  <li>Divide and conquer too.</li>
  <li>Binary search has lookup method by <strong>implementing trees as we saw on tree DS</strong>.</li>
  <li>This has <code class="language-plaintext highlighter-rouge">O(log n)</code>.</li>
  <li>But sometimes we need to traverse all nodes, there are other strategies for that.</li>
</ul>

<h2 id="traversal---graph--tree-traversals">Traversal - Graph + Tree Traversals</h2>

<p>Sometimes we want to add color property to all nodes. <strong>Traversals is like visiting every node</strong>.</p>
<ul>
  <li>How can we traverse a Tree / Graph?
    <ul>
      <li>With Breadth-first search (BFS), Depth-first search (DFS).</li>
      <li>Both have <code class="language-plaintext highlighter-rouge">O(n)</code>.</li>
    </ul>
  </li>
  <li>Main benefit we don’t put them on Arrays or Hash Tables is order and good O(log n) instead of O(n).</li>
  <li>Trees / Graphs are used a lot in traversal.</li>
</ul>

<h2 id="breadth-first-search-bfs--depth-first-search-dfs">Breadth-first search (BFS) &amp; Depth-first search (DFS)</h2>

<h3 id="bfs--dfs-intro">BFS &amp; DFS Intro</h3>

<ul>
  <li>BFS:
    <ul>
      <li>Start with root node and move left to right across second, third level, and so on.
        <ul>
          <li>Until you find node you’re looking OR tree ends.</li>
        </ul>
      </li>
      <li><strong>BFS uses more memory b/c it tracks child nodes</strong>. So there are implications</li>
    </ul>
  </li>
  <li>DFS:
    <ul>
      <li>Follows one branch until is on last leave then moves forward checking unexplored children and branches.</li>
      <li><strong>Lower memory requirement. Don’t need to store all child pointers</strong>.</li>
      <li>So until it hits dead end then moves.</li>
    </ul>
  </li>
  <li>BFS / DFS:</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//OUR TREE</span>
<span class="c1">//     9</span>
<span class="c1">//  4     20</span>
<span class="c1">//1  6  15  170</span>


<span class="c1">// BFS: Visits all levels and outputs a list as it finds what it needs </span>
<span class="c1">// [9,4,20,1,6,15,17]</span>


<span class="c1">// DFS: List is different</span>
<span class="c1">// [9,4,1,6,20, 15,17]</span>

</code></pre></div></div>

<h3 id="bfs-vs-dfs">BFS vs DFS</h3>
<p>BFS is like water from top to down. DFS is like lines.</p>

<p>When to use BFS or DFS? Time complexity is <strong>same for both</strong> <code class="language-plaintext highlighter-rouge">O(n)</code></p>

<ul>
  <li>BFS:
    <ul>
      <li>Good for <strong>finding shortest path</strong>. As it checks closer nodes.</li>
      <li>Bad: More memory</li>
      <li>If you have additional info and know where the node is, use BFS.</li>
    </ul>
  </li>
  <li>DFS:
    <ul>
      <li>When you know node is in lower level then use DFS.</li>
      <li>Ask the question <strong>does the path exist</strong></li>
      <li>Good: Less memory</li>
      <li>Bad:** it can get slow if tree is very deep not very good finding shortest path**</li>
    </ul>
  </li>
  <li><a href="https://stackoverflow.com/questions/9844193/what-is-the-time-and-space-complexity-of-a-breadth-first-and-depth-first-tree-tr">Good Resource</a>.</li>
</ul>

<h2 id="common-interview-questions-bfs-vs-dfs">Common Interview Questions BFS vs DFS</h2>

<p>Study to see how you explain to interviewer</p>

<ol>
  <li>If you know a solution is NOT far from the root of the tree:
    <ul>
      <li>BFS - starts searching closest nodes first.</li>
    </ul>
  </li>
  <li>If the tree is VERY deep and solutions are rare,
    <ul>
      <li>BFS (DFS will take long time. )</li>
    </ul>
  </li>
  <li>If the tree is very wide:
    <ul>
      <li>DFS (BFS will need too much memory as it has to keeps track of all the nodes)</li>
    </ul>
  </li>
  <li>If solutions are frequent but located DEEP in the tree
    <ul>
      <li>DFS</li>
    </ul>
  </li>
  <li>determining whether a path exists between two nodes
    <ul>
      <li>DFS</li>
    </ul>
  </li>
  <li>Finding the shortest path
    <ul>
      <li>BFS</li>
    </ul>
  </li>
</ol>

<h2 id="coding-bfs--dfs">Coding BFS &amp; DFS</h2>

<h3 id="breadth-first-search---exercises">Breadth-first Search - Exercises</h3>
<ul>
  <li><a href="https://repl.it/@fbohz/Data-Structures-Trees-traversals-bfs">Code Here</a>.</li>
  <li>Uses a queue array</li>
  <li>Usually is done with iteration.</li>
</ul>

<h3 id="breadth-first-search-recursive---exercises">Breadth-first search (Recursive) - Exercises</h3>
<ul>
  <li><a href="https://repl.it/@fbohz/Data-Structures-Trees-traversals-bfs-recursive">Code Here</a>.</li>
  <li>Just for fun.</li>
</ul>

<h3 id="depth-first-search---exercises">Depth-first search - Exercises</h3>
<ul>
  <li><a href="https://repl.it/@fbohz/DFS-InOrder-PostOrder-PreOrder-Trees-Traversals">Code here</a>.</li>
  <li><strong>stack</strong> DS used here as it is Recursion. Height of tree will tell how much memory, memory consumption will depend on that.</li>
  <li>preOrder: from parent</li>
  <li>inOrder: order of nodes</li>
  <li>postOrder: order from trees at the bottom</li>
  <li>Play with code and console log to see how it inputs</li>
  <li><strong>main difference is the order you get output</strong></li>
  <li><strong>depending on your needs you might implement one or the other</strong></li>
  <li>You just learned how to traverse through tree try to implement in a graph!</li>
</ul>

<h3 id="validate-a-bst---interview-qs">Validate a BST - Interview Qs</h3>
<ul>
  <li>A very common question you will get asked in an interview is <strong>how to validate a binary search tree</strong>! Hint, you want to use <strong>BFS</strong> for this.</li>
  <li>Try it <a href="https://leetcode.com/problems/validate-binary-search-tree/">here</a>.</li>
</ul>

<h3 id="graph-traversals">Graph Traversals</h3>
<ul>
  <li>Tree traversal will be the same as Graph traversal. <strong>Trees are a type of graphs</strong>.</li>
  <li>Graphs model real life, like recommendation engine (items related) using like BFS. Facebook what type of friend request or LinkedIn connection with DFS.</li>
  <li><a href="https://visualgo.net/en/dfsbfs?slide=1"><strong>See it in action</strong></a></li>
</ul>

<p><strong>Remember</strong></p>
<ul>
  <li>DFS is for shortest path. Closest to our node. Related items on Amazon, closest connections.</li>
  <li>DFS check if it exists. We can go very deep very fast.</li>
  <li>BFS in Graphs:
    <ul>
      <li>What’s the closest node to 0? BFS is very good as it looks closest nodes first.</li>
    </ul>
  </li>
  <li>DFS in Graphs:
    <ul>
      <li>Great for solving a maze. Because it goes deep then backtracks to solve the puzzle until finds exit.</li>
      <li>Idea of backtracking after dead end is just recursion.</li>
      <li>It answers does the path exist?</li>
      <li>If very deep branch can get very slow. Needs to keep track of all the functions on the stack.</li>
    </ul>
  </li>
</ul>

<h2 id="dijkstra--bellman-ford-algorithms">Dijkstra + Bellman-Ford Algorithms</h2>

<ul>
  <li><strong>In interview you’ll probably don’t implement them</strong></li>
  <li>BFS <strong>doesn’t care about weight</strong>. So doesn’t take to account weighted graphs.</li>
  <li>Dijkstra / Bellman-Ford Algorithms:
    <ul>
      <li><strong>Find the shortest path between two nodes on a weighted graph</strong>.</li>
      <li>Bellman can accommodate negative weights and Dijkstra doesn’t.</li>
      <li>Dijkstra is faster than Bellman’s (worst case is O(n^2)).</li>
    </ul>
  </li>
</ul>

<p>In an Interview:</p>
<ul>
  <li>These algorithms are very <strong>complex</strong></li>
  <li>Know that they exist and how to use them.</li>
  <li>If you see a weighted graph and asked to find best algorithm:
    <ul>
      <li>BFS can’t be used because is weighted</li>
      <li>Negative weights? If YES, Bellman. If NO, Dijkstra.</li>
    </ul>
  </li>
</ul>

<p><a href="https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e">Read more</a>.</p>
<h2 id="searching--traversal-review">Searching + Traversal Review</h2>
<ul>
  <li>Searching and Traversal are one of the most popular algorithms.</li>
  <li>Learned about how to traverse tree/graph.</li>
  <li>Now we’re better to equipped to answer questions.</li>
  <li>Review the <strong>Technical Interview Mind Map</strong>.</li>
  <li><a href="https://coggle.it/diagram/W5E5tqYlrXvFJPsq/t/master-the-interview-click-here-for-course-link">More here</a>.</li>
</ul>

<h2 id="dynamic-programming-dp">Dynamic Programming (DP)</h2>

<ul>
  <li>DP is just optimization technique using cache. If you can cache then you can do DP. So its just a buzz word a lot of times.</li>
  <li>DP solves problems by breaking it down into sub problems, storing solutions in case those sub problems arise.</li>
  <li>DP
    <ul>
      <li>Divide and Conquer + Memoization (cache)</li>
    </ul>
  </li>
</ul>

<h2 id="memoization">Memoization</h2>

<ul>
  <li>Caching is a way to store values that you can use later. Like a backpack that holds items you need.</li>
  <li>Memoization is a specific caching we use in our programs.</li>
</ul>

<p><strong>Memoization example</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">add80</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">80</span>
<span class="p">}</span>

<span class="nx">add80</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

</code></pre></div></div>

<p>What if this operation took a long time? Can we optimize it with memoization?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">add80</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">80</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{}</span>

<span class="kd">function</span> <span class="nx">memoAdd80</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="k">in</span> <span class="nx">cache</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//O(1)</span>
        <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">80</span>
        <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>What is then memoization?</p>

<ul>
  <li>Caches return value based on parameters. <strong>If param of function doesn’t change then its memoized then it will return cache version</strong>. If parameter changes then calculates as usual.</li>
  <li><strong>So its a way to remember a solution to a problem so you don’t have to calculate again</strong>.</li>
</ul>

<h3 id="closures-in-memoization">Closures in Memoization</h3>

<p>Patterns in DP:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">memoAdd80</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">cache</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1">//closure returns a function</span>
    <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="k">in</span> <span class="nx">cache</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">//O(1)</span>
          <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">80</span>
          <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">memoized</span> <span class="o">=</span> <span class="nx">memoAdd80</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">memoized</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="c1">// console.log(cache)</span>
<span class="c1">// console.log('-----------')</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">memoized</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>

</code></pre></div></div>
<ul>
  <li>Closures <strong>return a fn inside a fn</strong></li>
  <li>Because of closure we can <strong>avoid global scope</strong> and access cache.</li>
</ul>

<h3 id="fibonacci-and-dp-caching">Fibonacci and DP (caching)</h3>

<p>Remember recursion example.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">let</span> <span class="nx">calculations</span> <span class="o">=</span> <span class="mi">0</span>
<span class="kd">function</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">calculations</span><span class="o">++</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">n</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fib</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">fib</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="c1">//will take a long time</span>
<span class="c1">// fib(30)</span>
</code></pre></div></div>

<ul>
  <li>Remember this is pretty bad! O(2^n). <strong>We’ll never want to implement this in real life</strong>.
    <ul>
      <li>This because we repeat a lot of calculations.</li>
    </ul>
  </li>
  <li><strong>Can we fix this with caching (DP)</strong>? Reduce it to O(n)
    <ul>
      <li>Yes we can because the solution is optimal and we do the same.</li>
      <li>We can actually return a memoized version with O(1) and use the cached version.</li>
    </ul>
  </li>
</ul>

<p>Solving fibonacci. See below or <a href="https://repl.it/@fbohz/BlogDPSolvingFibonacci#index.js">here</a>.</p>

<iframe height="400px" width="100%" src="https://repl.it/@fbohz/BlogDPSolvingFibonacci?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>

<p>Note: we increased the space complexity with memoization.</p>

<h2 id="assess-when-to-use-dp-caching--memoization">Assess when to use DP (caching / memoization)</h2>

<p>Think about your problem like this to implement DP:</p>

<ol>
  <li>Can it be divided into subproblem. Problem broken down into smaller problems.</li>
  <li>Recursive solution</li>
  <li>Are there repetitive sub-problems?
    <ul>
      <li>Same calculation over and over? <strong>we can memoize the problem!</strong></li>
    </ul>
  </li>
  <li>Memoize sub-problems</li>
  <li>Implement caching! and save a lot of calculations!</li>
</ol>

<h2 id="interview-questions-dynamic-programming">Interview Questions: Dynamic Programming</h2>

<p>Here are some popular Dynamic Programming Questions (see if you can notice the pattern):</p>

<ol>
  <li><a href="https://leetcode.com/problems/house-robber">House Robber</a></li>
  <li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock">Best Time to Buy and Sell Stock</a></li>
  <li><a href="https://leetcode.com/problems/climbing-stairs">Climbing Stairs</a></li>
</ol>

<h2 id="review-of-dp">Review of DP</h2>

<ul>
  <li><strong>All you need is to remember the pattern of saving a cache variable and use closures to return a function within a function</strong>.</li>
  <li>If there’s repeated calculation then get the memoized result.</li>
  <li>Memoized version has more space complexity, so this tradeoff is necessary.</li>
  <li><strong>Other way to incorporate DP is bottom up approach</strong>.</li>
  <li>This one avoids recursion. Starts from simple to higher solutions.</li>
  <li>This one is <strong>harder to know how/when to use</strong></li>
  <li>Interview is unlikely that they will ask you to implement both methods.</li>
  <li><strong>In short memoization help us to avoid having to do repeated tasks</strong>. If you can implement this you’re on your way to become a great engineer.</li>
</ul>
:ET