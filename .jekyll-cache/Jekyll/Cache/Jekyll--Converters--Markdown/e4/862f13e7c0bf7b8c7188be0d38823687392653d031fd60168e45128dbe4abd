I"É><blockquote>
  <p>Handling payments is very complex, not talking the security risks one can take if handling payment information. Stripe API, make things easier, secure and faster to deploy</p>
</blockquote>

<h1 id="react-hooks-going-beyond-usestate">React Hooks: Going Beyond <code class="highlighter-rouge">useState</code></h1>

<p>Hooks were implemented in 2019. They have very interesting features and bring some changes to building components. Hooks can only be used in React 16 or higher and on functional components. Read about the motivation to add React Hooks <a href="https://reactjs.org/docs/hooks-intro.html#motivation">here</a>.</p>

<p>Now probably by know, everyone with some React knowledge should know about the <code class="highlighter-rouge">useState</code> Hook. It lets us use state in functional components. You can use as many as use state hooks as needed. This is an alternative to setting state with deeply nested objects. On this article weâ€™ll go beyond useState and explore other hooks.</p>

<p><strong>useEffect</strong></p>

<p><code class="highlighter-rouge">useEffect</code> lets us employ lifecycle kind of methods to functional components. This has to do with dealing with side-effects including API calls.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// mimics as a render lifecycle method</span>

<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// ...assume this code on an input</span>
<span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="nx">e</span> <span class="o">=&gt;</span> <span class="nx">setQuery</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span>

<span class="c1">// useEffect gets called whenever onChange changes value</span>

</code></pre></div></div>

<p>useEffect does not get a value, but gets a function that gets called whenever the component changes/updates and re-renders. It works as componentDidMount and also as the render method when the component gets updated.</p>

<p>If we want to use useEffect as componentDidMount we add an array as second argument.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">)</span>
<span class="p">},[])</span>

</code></pre></div></div>

<p>The array takes an array of properties we want to watch and it will render if those properties change. If the array is empty is like componentDidMount. Now how could we implement an API call using useEffect?</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">query</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">fetchUser</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">baseURL</span><span class="dl">'</span><span class="p">)</span>
            <span class="kd">const</span> <span class="nx">resJson</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
            <span class="c1">//useState call</span>
            <span class="nx">setUser</span><span class="p">(</span><span class="nx">resJson</span><span class="p">)</span>
        <span class="p">}</span>
    
        <span class="nx">fetchUser</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">},[</span><span class="nx">query</span><span class="p">])</span>

</code></pre></div></div>

<p>Make sure you add the <em>empty array</em>, or with special properties if you plan it to run it once. In this case it will update if the search query updates on the example above. The conditional then ensures we are calling useEffect if queries are valid. You can read more about <a href="https://reactjs.org/docs/hooks-rules.html">Hook rules</a>.</p>

<p><em>Note</em>: You might get a warning when using useEffect that says something like â€˜React Hook useEffect has a missing dependencyâ€¦etcâ€™. To add a safeguard if calling an API pass in the api in the array list as such:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// behaves like componentDidMount avoids missing dependency warning</span>
    <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">checkUserSession</span><span class="p">()</span>
    <span class="p">},</span> <span class="p">[</span><span class="nx">checkUserSession</span><span class="p">])</span>

</code></pre></div></div>

<p><strong>useEffect as componentWillUnmount</strong></p>

<p>We can also pass a cleanup function, so return a function from a function. This is useful when implementing subscriptions, so on the cleanup function it will be for unsubscribing.</p>

<p><img src="https://user-images.githubusercontent.com/15071636/84339775-cb0e1b00-ab64-11ea-8100-21328333460d.png" alt="Screen Shot 2020-06-10 at 9 52 11 PM" /></p>

<p><strong>useEffect Boilerplate Code</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ComponentDidMount</span>
<span class="c1">//Class</span>
<span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I just mounted!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="c1">//Hooks</span>
<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I just mounted!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="p">[])</span>


<span class="c1">//ComponentWillUnmount</span>
<span class="c1">//Class</span>
<span class="nx">componentWillUnmount</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am unmounting</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="c1">//Hooks</span>
<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am unmounting</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="p">[])</span>


<span class="c1">// ComponentWillReceiveProps</span>
<span class="c1">//Class</span>
<span class="nx">componentWillReceiveProps</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">nextProps</span><span class="p">.</span><span class="nx">count</span> <span class="o">!==</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">count changed</span><span class="dl">'</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="c1">//Hooks</span>
<span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">count changed</span><span class="dl">'</span><span class="p">,</span> <span class="nx">props</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span>
<span class="p">},</span> <span class="p">[</span><span class="nx">props</span><span class="p">.</span><span class="nx">count</span><span class="p">])</span>

</code></pre></div></div>

<p><strong>Reusable Custom Hooks</strong></p>

<p>Sometimes you might have similar situations in which youâ€™re using the same hooks, with very small differences.  Lets say youâ€™re fetching with useEffect then setting state depending on the return of the fetch. Hereâ€™s where reusable Hook components work.</p>

<p>Hereâ€™s how we can implement custom hooks:</p>

<ol>
  <li>Create new folder called â€˜effectsâ€™ then a file with the name of your custom hook with the â€˜useâ€™ keyword. E.g. â€˜useFetchâ€™.</li>
  <li>Create your custom hook. E.g.</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/15071636/84421224-db63db80-abe0-11ea-9fe5-fe6addc1779f.png" alt="Screen Shot 2020-06-11 at 12 26 38 PM" /></p>

<ol>
  <li>Import it and use it</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/15071636/84421372-16fea580-abe1-11ea-9bb1-9cbc68fb35b7.png" alt="Screen Shot 2020-06-11 at 12 42 25 PM" /></p>

<p>It is like writing utility functions. Then you can make those custom hooks to share functionality.</p>

<p>Note also the example thereâ€™s no second argument with the <code class="highlighter-rouge">[]</code> passed so it gets called whenever the <code class="highlighter-rouge">useFetch</code> custom hook gets called. We could also pass the â€˜urlâ€™ as the second argument. Since our user might change and there are no dependencies here we donâ€™t pass the second argument in this use case. So in this case the component that use it, will fire the useFetch whenever it re-renders.</p>

<p><strong>useReducer</strong></p>

<p>The useReducer hook can be similar as to what you use with Redux. useReducer is for cases where you need more complex state management than useState. You can read the documentation <a href="https://reactjs.org/docs/hooks-reference.html#usereducer">here</a>.</p>

<p>Consider the following <a href="https://gist.github.com/fbohz/6440ad94a264336fe6c2b00c2ce2131f">useReducer example</a>.</p>

<script src="https://gist.github.com/fbohz/6440ad94a264336fe6c2b00c2ce2131f.js"></script>

<p>As you can see is similar to Redux. We also destruct different values. In the useReducer, we pass the reducer and the initial state value.</p>

<p>The initial state we created accordingly and the reducer is just like in Redux. Then you can see the action creators setUser and setQuery with types and payload, again like Redux. Now how we pull the values we destruct them from our state variable and we dispatch them with our dispatch, e.g. <code class="highlighter-rouge">dispatch(setUser(resJson[0]))</code>. So React seems to be moving in which we might or not want to use Redux in our case or the other.</p>

<p><strong>Implementing Context API with <code class="highlighter-rouge">createContext</code> and <code class="highlighter-rouge">useContext</code></strong></p>

<p>Context API was recently updated by the React team. Context API is also used by Redux but now is more powerful. Context API tries to solve props drilling, and is a way to store different states in separate components and add them as Hooks. This is done like Redux.</p>

<p>In order to implement context Hook:</p>

<ul>
  <li>Create the context using createContext</li>
  <li>Import the context you created and also the useContext library. Pass in the context created to useContext as your context. E.g. <code class="highlighter-rouge">const myContext = useContext(sampleContext)</code>.</li>
</ul>

<p>In Studio Ghibli Fan App we implemented this in the <a href="https://github.com/fbohz/studio-ghibli-fan-app-demo/blob/1.4.0.5_ContextAPI/src/pages/collection/Collection.js">Collection page</a>. The context created can be found <a href="https://github.com/fbohz/studio-ghibli-fan-app-demo/tree/1.4.0.5_ContextAPI/src/contexts/collections">here</a>.</p>

<p><strong>Dynamically Set Values with Context API</strong></p>

<p>Here we take advantage of Context.Provider. We implemented it on <a href="https://github.com/fbohz/studio-ghibli-fan-app-demo/blob/1.4.0.5_ContextAPI/src/App.js">App.js</a> wrapping the header to pass the currentUser context. We use the <code class="highlighter-rouge">value</code> attribute to pass the state we need on on to the Context Consumer in this case Header. So if currentUser changes then Header, as the consumer re-renders. Take a look at how Header consumes the context created <a href="https://github.com/fbohz/studio-ghibli-fan-app-demo/blob/1.4.0.5_ContextAPI/src/components/Header.js">here</a>.</p>

<p>We can even create whole providers with Context API that we pass into our own index.js just like Redux.</p>

<p>Here you might see a <em>caveat</em> that we have to re-leverage component state to use this created context. But it can be easier to pass state into nested components. Remember we are solving prop drilling.</p>

<p><strong>Context API vs Redux</strong></p>

<p>It is rare that you have an app that uses both. But youâ€™ll have to decide. Things like Redux-persist, Redux-logger still are pretty robust and difficult to implement fast with Context API. Redux is more opinionated but with Context API we loose sagas, thunk, etc. Context API might make our component less reusable as we tight the components to their specific contexts they live. Also as app grows with Context API you might be having a lot of providers in index.js while redux thereâ€™s the root provider. So Redux for larger scale apps might be a better go. Context API would be good for a portfolio project or small landing page with not that much reusability.</p>

<p><strong>Should we adopt Hooks?</strong></p>

<p>Hooks are fairly new, but apps are using them, thereâ€™s still a lot of hype around them. A lot of companies have built scalable apps without hooks, so itâ€™ll take time to migrate to hooks. Below are some resources you can use in your learning of these exciting hooks.</p>

<ul>
  <li><a href="https://react-redux.js.org/next/api/hooks">React Redux Hooks</a>. Look into the useSelector.</li>
  <li><a href="https://overreacted.io/a-complete-guide-to-useeffect/">Complete guide of useEffect</a>.</li>
</ul>
:ET