I"`F<blockquote>
  <p>Learning about data structures is an essential part of becoming a more experienced developers. This is the second part of the series, and will be the longest one, buckle down.</p>
</blockquote>

<h1 id="learning-about-data-structures-part-2">Learning About Data Structures Part 2</h1>

<p>Learning about data structures is an essential part of becoming a more experienced developers. This is the second part of the series, and will be the longest one, buckle down.</p>

<h2 id="stacks--queues">Stacks &amp; Queues</h2>

<ul>
  <li>Stack and queues are very similar to linear data structures.</li>
  <li>Only difference is how items are removed.</li>
  <li>Stack and queues have less methods. This could be an advantage as it could limit what can be done.</li>
</ul>

<p><strong>Stacks are like plates</strong></p>
<ul>
  <li>You can only touch the first plate, and go one by one. This is <strong>called last in first out (LIFO)</strong></li>
  <li>These are very good to know the very last value.</li>
  <li>Most programming languages have a stack mindset like LIFO.</li>
</ul>

<p><strong>Other uses</strong></p>

<ul>
  <li>Browser history. Undo/Redo. This idea comes from stack.</li>
  <li>Methods are pop() - O(1), push() - O(1) and peek() - O(1). Traverse is not recommended in stack.</li>
</ul>

<p><strong>Queues</strong></p>

<p>Are like an entrance to a rollercoaster. They have a <strong>first in first out (FIFO)</strong></p>

<p>Uses:</p>

<ul>
  <li>If you have a wait-list app, could use queues. Restaurant to see if you have table, could use queues. Uber/Lyft uses queues. Printers too.</li>
  <li>Methods are enqueue() - O(1), dequeue() - O(1) and peek() - O(1). Again traversing is not recommended (lookup())</li>
  <li>Dequeue() unlike pop() takes first person, pop() in stack takes last.</li>
  <li><em>Do not build a queue using arrays since its inefficient</em>.</li>
</ul>

<h2 id="stack-and-queues-implementations">Stack and Queues Implementations</h2>

<p>How can you build stack and queues in JS?</p>
<ul>
  <li>Stacks: Arrays or Linked Lists
    <ul>
      <li><strong>Both work very well.</strong></li>
      <li>Think about what are your needs.</li>
    </ul>
  </li>
  <li>Queues: Arrays or Linked lists.
    <ul>
      <li><strong>Arrays not recommended</strong>. Because you have to traverse O(n) when you shift and remove.</li>
      <li>Use always Linked Lists</li>
    </ul>
  </li>
</ul>

<h3 id="stack--queues-examples">Stack / Queues Examples</h3>

<p>See below or click <a href="https://repl.it/@fbohz/BlogStackQueuesEG#index.js">here</a>.</p>

<iframe height="400px" width="100%" src="https://repl.it/@fbohz/BlogStackQueuesEG?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>

<h3 id="stack--queues-review">Stack / Queues Review</h3>

<ul>
  <li>Stacks are like plates. Queues are like waiting lists</li>
  <li>Stacks and Queues are great for removing and inserting. <strong>fast peek</strong></li>
  <li>Data is ordered.</li>
  <li><strong>Do not use Arrays when building queues. Because you have to traverse O(n) when you shift and remove.</strong></li>
  <li><strong>Slow lookup for both.</strong></li>
</ul>

<p>For example interview Question check <a href="https://leetcode.com/problems/implement-queue-using-stacks/description/">discussion</a>. Solution below and <a href="https://repl.it/@fbohz/BlogQueueUsingStacksQS#index.js">here</a>.</p>

<iframe height="400px" width="100%" src="https://repl.it/@fbohz/BlogQueueUsingStacksQS?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>

<h2 id="trees">Trees</h2>

<ul>
  <li>Trees have a hierarchical structure.</li>
  <li>Linked lists, arrays are linear. Linked lists are considered a type of tree</li>
  <li>Trees have <strong>only one parent</strong> and it can <strong>leaf notes</strong></li>
  <li>Within trees you can have <strong>sub trees</strong></li>
  <li>Example:
    <ul>
      <li>DOM is a tree data structure. HTML is parent then body is parent with many children.</li>
    </ul>
  </li>
  <li>Facebook comments have a tree DS, with commments of comments etc.</li>
  <li>Abstract syntax tree. Code is broken down by a machine as this.</li>
  <li>There are many tree data structures.</li>
</ul>

<h2 id="binary-trees">Binary Trees</h2>

<ul>
  <li>Each node can only have 0,1,2 nodes. Each node represents a certain state.</li>
  <li>Each child can only have one parent.</li>
  <li>Types of binary trees:
    <ul>
      <li><strong>Perfect Binary tree</strong> - nodes are full nothing is missing. They are efficient. Number of nodes double as it goes down. Second property states that bottom levels equal top levels + 1. <strong>So there are some efficiencies here</strong> as O(log N)</li>
      <li><strong>Full binary tree</strong> - the opposite and only meets requirements of binary tree.</li>
    </ul>
  </li>
</ul>

<h2 id="olog-n---reminder">O(log n) - Reminder</h2>
<ul>
  <li>There is a certain way to calculate num of nodes of perfect binary trees.
    <ul>
      <li>You calculate 2 to the power of level in question.
        <ul>
          <li>E.g. Level 0: 2^0 = 1. Number of nodes: 1. Lvl 2: 2^2 = 4. etc.</li>
        </ul>
      </li>
      <li>Based on this formula you can do 2^treeHeight - 1 to know how many total nodes. E.g. 3 Level Tree: 2^3 - 1 = 7 nodes.
        <ul>
          <li>We can simplify as <strong>log notes = treeHeight</strong>. So you by knowing this, you can limit steps by going in one branch.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>So O(log n) is like <strong>divide and conquer</strong>. Choice of next element is one of several. We only choose one not all.
    <ul>
      <li><strong>Like looking throgh a phonebook</strong>. You look based upon the names you want. So divide an conquer. Only need to explore subset of tree.</li>
    </ul>
  </li>
  <li>Binary search trees allows us to search efficiently. Google uses this method too.</li>
</ul>

<h2 id="binary-search-trees-bst---most-common-tree-ds">Binary Search Trees (BST) - Most common Tree DS.</h2>

<ul>
  <li>What is BST:
    <ul>
      <li>They are <strong>really good at searching</strong>, comparing things.</li>
      <li>This DS preserves relationships. Like folders, parent folder, subfolder etc., they have unlike Hash Tables.
        <ul>
          <li>e.g.
  101
  /  <br />
  33   105
  / \    / <br />
  9  37  104 144</li>
          <li>Here lookup is very easy you can find by going left of right depending on number.</li>
          <li>insert and delete are also O(log n). For example delete 105, decide which node takes place. Reordering those happens.
            <ul>
              <li>Always traversing and with conditionals saving time to insert, delete.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Resource: https://visualgo.net/bn/bst?slide=1</li>
</ul>

<h3 id="bst-pros-and-cons">BST Pros and Cons</h3>

<ul>
  <li>Very good performance better than O(n), assuming bST is balanced.</li>
  <li>Ordered and flexible size.</li>
  <li>No O(1) operations, since traversal is required.</li>
  <li>BST is not the fastest, sometimes Arrays out perform them.</li>
</ul>

<h3 id="unbalanced-vs-balances-bst">Unbalanced vs Balances BST</h3>

<ul>
  <li><strong>Unbalanced BST</strong>: Where are the nodes are either on the right or left. Becoming more like linked lists. Unbalanced become O(n) for lookup, insert, delete.</li>
  <li><strong>Balanced (PREFERRED)</strong>: How do you balance your trees?
    <ul>
      <li>By algorithms. Programming languages provide libraries and tools for this.</li>
    </ul>
  </li>
</ul>

<h3 id="bst-exercise">BST Exercise</h3>

<p>See below or click <a href="https://repl.it/@fbohz/BlogBST-eg">here</a>.</p>

<h3 id="avl-trees--red-black-tree-balancing-binary-search-trees">AVL Trees + Red Black Tree (Balancing Binary Search Trees)</h3>

<ul>
  <li>These trees are used a library and balance trees.</li>
  <li>These balance the trees when finds they are not unbalanced.</li>
  <li>There are resources for you to visualize them:
    <ul>
      <li>https://medium.com/basecs/the-little-avl-tree-that-could-86a3cae410c7</li>
      <li>https://medium.com/basecs/painting-nodes-black-with-red-black-trees-60eacb2be9a5</li>
      <li>https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</li>
      <li>https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</li>
    </ul>
  </li>
</ul>

<h3 id="binary-heaps-and-trie">Binary Heaps and Trie</h3>

<p><strong>Heaps</strong></p>

<ul>
  <li>Mostly Binary Heaps.
    <ul>
      <li><strong>Parent greater than children</strong>.</li>
      <li>Like priority queues, sorting algorightms.</li>
      <li>But left and right can be any value. So lookup as O(n) here.</li>
      <li>They are good at doing comparitve.</li>
      <li><strong>Thereâ€™s left to right insertion</strong>. You can implement binary heap with arrays.</li>
    </ul>
  </li>
  <li>Priority Queue:
    <ul>
      <li>Different than queues with FIFO.</li>
      <li><strong>Elements with higher priority are server before than lower priority</strong>.</li>
      <li>Example of priority queue:
        <ul>
          <li>Emerency room, airplane boarding.</li>
        </ul>
      </li>
      <li>It gives a sense of structure and order.</li>
    </ul>
  </li>
</ul>

<p><code class="highlighter-rouge">Memory Heap != Heap Data Structure in JS.</code></p>

<ul>
  <li>Searching lookup is slower.</li>
  <li>Gives idea of priority.</li>
  <li>Most of the time insert is fast.</li>
  <li>Methods like find max and fin min are available and very fast.</li>
</ul>

<p><strong>Trie:</strong></p>

<ul>
  <li>Specialized tree used in searching, most often with text.</li>
  <li>In most cases it outperform most data structures, depending what is doing.</li>
  <li>How it works:
    <ul>
      <li>Empty root node.</li>
      <li>Letters are added after.</li>
      <li>They are also called <strong>prefixed tree</strong>, like autocompleted.</li>
      <li>Used for searching words on dictionary, word suggestions.</li>
    </ul>
  </li>
  <li>Lookup here is fast, you look for length then move. Space complexity also has advantages. Prefixes save space.</li>
</ul>

<h2 id="trees-conclusion">Trees Conclusion</h2>

<ul>
  <li><a href="https://github.com/afiore/arboreal"><strong>Arboreal.js</strong></a> lets you use it and create the tree you want. You wonâ€™t be creating trees from scratch.</li>
  <li>You need to understand how they work.</li>
  <li>Try to practice and build one from scratch.</li>
</ul>

<h2 id="graphs">Graphs</h2>

<p>Last data structure!</p>

<ul>
  <li>Graph is a set of values related in pair fashion.
    <ul>
      <li>Like a network</li>
      <li>Each item is called a node or vertex.</li>
      <li>Nodes are connected with edges.</li>
    </ul>
  </li>
  <li>They model real work relationships. Kind of like internet works.</li>
  <li>To represent roads, friends. Google maps uses graphs to determine shortest map.</li>
  <li><strong>Linked lists, trees are a type of graphs!</strong></li>
</ul>

<h2 id="types-of-graphs">Types of Graphs</h2>

<ul>
  <li>Directed vs Undirected
    <ul>
      <li><strong>Directed</strong>:
        <ul>
          <li>One way street.</li>
          <li>Twitter is more directed if they follow me i donâ€™t necessarily follow them</li>
        </ul>
      </li>
      <li><strong>Undirected</strong>:
        <ul>
          <li>Two way street.</li>
          <li>Facebook is undirected a friend can be connected to another</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Unweighted and Weighted
    <ul>
      <li>Weighted graphs has information in the edges / connections too.
        <ul>
          <li>Google Maps uses weighted graphs. Like fastes way in 1-6.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Cyclic vs Acyclic
    <ul>
      <li>If vertices are connected in a cycle are cyclic.
        <ul>
          <li>Cyclic are common in weighted because thereâ€™s a way to go back.</li>
        </ul>
      </li>
      <li>Example: https://internet-map.net/</li>
    </ul>
  </li>
  <li>Directed Acyclic Graph is common in projects such as IOTA a blockchain project.
    <ul>
      <li>Many trees can also create this data structure.</li>
      <li>There are some online graphs you can see and check to test your knowledge.</li>
    </ul>
  </li>
</ul>

<h2 id="graph-exercise">Graph Exercise</h2>
<ul>
  <li>Building / representing a graph. Considering this graph how can you build it.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  2 - 0
  /  \
  1   3
</code></pre></div>    </div>
  </li>
</ul>

<p>Some options:</p>

<p><strong>Edge List</strong>: Like with an array of arrays. Stating the connections.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</code></pre></div></div>

<p><strong>Adjacent List</strong>: A graph like array, objects, linked lists. Index is the node, and value is the node neighbors.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
</code></pre></div></div>

<p><strong>Adjacent Matrix</strong>: will only have 0s and 1s if X have connections to note Y. 0 is no Y is yes.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="p">{</span>
   <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
   <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
   <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
   <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>
</code></pre></div></div>

<h2 id="exercise-graph-implementation">Exercise Graph Implementation:</h2>

<ul>
  <li><strong>Undirected / Unweighted Graph Example</strong>.</li>
  <li>Using adjacency list. For the adjacency list. <strong>Use a hash table</strong>.</li>
  <li>We use objects because shifting/unshifting in Arrays is expensive.</li>
</ul>

<p>See below or click <a href="https://repl.it/@fbohz/BlogGraphExample#index.js">here</a> for the example code.</p>

<iframe height="400px" width="100%" src="https://repl.it/@fbohz/BlogGraphExample?lite=true" scrolling="no" frameborder="no" allowtransparency="true" allowfullscreen="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals"></iframe>

<h2 id="review-graphs">Review Graphs</h2>

<ul>
  <li>They look pretty complex but they are pretty simple once you have other DS taken care of.</li>
  <li><strong>In interviews graphs arenâ€™t that big because it takes time</strong>.</li>
  <li>Learn fundamentals.
    <ul>
      <li>Think how you hold data in graphs such as adjacency matrix</li>
      <li>Types of graphs</li>
      <li>How you can create graphs.</li>
    </ul>
  </li>
  <li>Performance and Big O is complicated because of so many graphs.</li>
  <li>There are algorithms to help.</li>
  <li>Scaling is hard as you will need a big team to build graph structures that scale well</li>
  <li><a href="https://neo4j.com/"><strong>Neo4j</strong></a> a tool to build complex structures as this.</li>
</ul>

<h1 id="data-structures-ds-review">Data Structures (DS) Review</h1>

<ul>
  <li>Technology is built on data structures. There might be more to come but you know the basics.</li>
  <li>Blockchain has hashes, linked lists, tries etc. Anyone can build their own data structure.</li>
  <li>With DS understood now you can take on algorithms that many companies ask.</li>
</ul>
:ET