I"¨U<blockquote>
  <p>If you apply 100 companies, it can be that 1% would actually get back to you. Starting this week Iâ€™ll begin some exploration on computer science concepts so you too can increase your response percentage to 5% or more.</p>
</blockquote>

<h1 id="simply-big-o">Simply BIG-O</h1>

<p>If you apply 100 companies, it can be that 1% would actually get back to you. Starting this week Iâ€™ll begin some exploration on computer science concepts so you too can increase your response percentage to 5% or more.</p>

<p><strong>What is good code?</strong></p>

<p>It usually means Readable and Scalable. <em>BIG O means  scalable code</em>:</p>

<ul>
  <li>Scalable means speed. It also means memory.</li>
  <li>Whatâ€™s the memory usage of code? You can use Big O for this too.</li>
  <li>Memory vs. Speed is usually a sacrifice. You get better speed you might have more memory.</li>
</ul>

<p>Note â€˜faster codeâ€™ (in terms how long it takes to compile) also depends of what CPU you have, the server etc. So itâ€™s hard to measure good code, in terms of how fast it performs.</p>

<p><strong>What is Big-O</strong></p>

<p>Big-O means: as inputs grows, how much does your function slow down? As elements, input increases how many <em>operations</em> does your function has to do?</p>

<ul>
  <li>The slower it slows down, the better.</li>
  <li>Big O calculates the number of steps and calculations <em>NOT</em> time it takes to run.</li>
</ul>

<p>BIG O is important for big applications. Scalable code is thinking long term. Since we cannot pin down the exact runtime (in seconds) of an algorithms we measure how <em>quickly the runtime grows in relation to its input and as the input gets immensely large</em>.</p>

<p>Good developers make these decisions efficiently. Big-O can give us reliable data in terms of <em>Time Complexity</em>. At the end weâ€™ll discuss about Space Complexity as well.</p>

<p>As we drill down Big-O notations below, please refer to the <a href="https://www.bigocheatsheet.com/">Big-O Cheatsheet</a> and to the graph below:</p>

<p><img src="https://user-images.githubusercontent.com/15071636/85084334-1db98980-b19a-11ea-8b28-d5e2076dc251.png" alt="Screen Shot 2020-06-18 at 7 29 26 PM" /></p>

<p>Remember we <em>cannot express speed in seconds</em>, so the size of the input we usually call it <code class="highlighter-rouge">n</code>. And the relationship with the algorithm so we could say for example our runtime grows lineally to the size of the input as O(n) or of the square of the size of the input as O(n^2). Letâ€™s go through each of these BigO examples.</p>

<h3 id="on---linear---preferred"><code class="highlighter-rouge">O(n)</code> - Linear - PREFERRED</h3>

<p>This is <strong>linear</strong>. As the number of elements increase so does the number of operations. Example:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  MESURE TIME SPENT</span>
<span class="kd">const</span> <span class="nx">nemo</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">nemo</span><span class="dl">'</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">large</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">199999</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="dl">'</span><span class="s1">nemo</span><span class="dl">'</span><span class="p">)</span> 

  <span class="kd">function</span> <span class="nx">findNemo</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">t0</span> <span class="o">=</span> <span class="nx">performance</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">nemo</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Found NEMO!</span><span class="dl">'</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">t1</span> <span class="o">=</span> <span class="nx">performance</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> 
  <span class="c1">// this is performance in speed </span>
  <span class="c1">// but is not crucial just for demo purposes.</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">t1</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">miliseconds</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>

<span class="nx">findNemo</span><span class="p">(</span><span class="nx">nemo</span><span class="p">);</span> <span class="c1">// O(n) -&gt; Linear Time</span>
</code></pre></div></div>

<h3 id="o1---constant-time---excellent"><code class="highlighter-rouge">O(1)</code> - Constant Time - EXCELLENT</h3>

<p>With O(1) it will always be the same calculation no matter how big the input grows.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">OnFn</span><span class="p">(</span><span class="nx">box</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">box</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>Note the 1 is arbitrary but this can be O(2), O(3) but do narrow it down to O(1) because to represent constant time. O(1) is used with Objects/Hash Tables data structures.</p>

<h3 id="on2---nested-loops---bad"><code class="highlighter-rouge">O(n^2)</code> - Nested Loops - BAD</h3>

<p>If you see nested loops you it is O(n^2)! So the performance decreases n^2 as input grows not lineally.</p>

<p><strong>You get interview questions to make O(n^2) into an O(n) or better</strong>. O(n^2) example:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Log all pairs of array</span>

<span class="kd">const</span> <span class="nx">boxes</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">d</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">e</span><span class="dl">'</span><span class="p">];</span>
<span class="kd">function</span> <span class="nx">logAllPairsOfArray</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">array</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="c1">// nested loops so O(n^2)</span>

<span class="nx">logAllPairsOfArray</span><span class="p">(</span><span class="nx">boxes</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="on---factorial-time---most-expensive-one"><code class="highlighter-rouge">O(n!)</code> - Factorial Time - MOST Expensive One</h3>

<p>It means you add a nested loop for every input. You probably would never see it.</p>

<h3 id="olog-n---excellent---used-in-tree-data-structures"><code class="highlighter-rouge">O(log n)</code> - EXCELLENT - Used in Tree Data Structures</h3>

<p>There is a certain way to calculate number of nodes of perfect binary trees:</p>

<ul>
  <li>You calculate 2 to the power of level in question.
    <ul>
      <li>E.g. Level 0: 2^0 = 1. Number of nodes: 1. Lvl 2: 2^2 = 4. etc.</li>
      <li>Based on this formula you can do 2^treeHeight, to know how many total nodes. E.g. 3 Level Tree: 2^3 - 1 = 7 nodes.</li>
      <li>We can simplify as <strong>log notes = treeHeight</strong>. So you by knowing this, you can limit steps by going in one branch.</li>
      <li>So O(log n) is like <strong>divide and conquer</strong>. Choice of next element is one of several. We only choose one not all.</li>
      <li>This like <strong>looking through a phone book</strong>. You look based upon the names you want. So <strong>divide an conquer</strong>. Only need to explore subset of tree.</li>
      <li>Binary search trees allows us to search efficiently. Google uses this method too.</li>
    </ul>
  </li>
</ul>

<h3 id="o2n-exponential-time---pretty-bad---worst-than-on2"><code class="highlighter-rouge">O(2^n)</code> Exponential time - PRETTY BAD - Worst Than O(n^2)</h3>

<p>A classic example is the fibonacci with recursion:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">num</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">num</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">){</span>
      <span class="k">return</span> <span class="nx">num</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> 
    <span class="o">+</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="on-log-n---ok---better-than-on2-but-worst-than-on"><code class="highlighter-rouge">O(n log n)</code> - OK - Better than O(n^2) but worst than O(n)</h3>

<ul>
  <li>This performs better than others.</li>
  <li><strong>Divide and conquer: Merge sort and quick sort use this conquer along with recursion</strong>.</li>
  <li>These <strong>donâ€™t have nested loops</strong>. See merge / quick sort for example.</li>
  <li>This O(n log n) is because it is still compared, everything at least once, but it is not compared everything to everything.</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  <span class="c1">// O(2^n)</span>
  <span class="kd">function</span> <span class="nx">fibonacciRecursive</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">){</span>
      <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">fibonacciRecursive</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="o">+</span> <span class="nx">fibonacciRecursive</span> <span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">fibonacciRecursive</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>

</code></pre></div></div>

<h2 id="simplifying-big-o-big-o-rules">SIMPLIFYING BIG-O (BIG-O RULES)</h2>

<p>1) <strong>Worst Case</strong>: Big-O cares at the worst case only.</p>
<ul>
  <li>Identify worst case. You could have O(1) but if O(n), then the Big-O is O(n).</li>
</ul>

<p>2) <strong>Remove Constants</strong>.</p>
<ul>
  <li>Identify things that donâ€™t change and remove them.</li>
  <li>E.g. you have two loops and so O(2n) but 2 is constant so itâ€™s actually O(n)
3) <strong>Different terms for inputs</strong></li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">compressBoxesTwice</span><span class="p">(</span><span class="nx">box1</span><span class="p">,</span> <span class="nx">box2</span><span class="p">)</span>
<span class="nx">box1</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">b</span> <span class="o">=&gt;</span> <span class="p">{</span>
       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>

<span class="p">})</span>
<span class="nx">box2</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">b</span> <span class="o">=&gt;</span> <span class="p">{</span>
       <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>

<span class="p">})</span>
</code></pre></div></div>

<p><strong>This is actually O(a + b) NOT O(n)</strong>. This because of different terms for inputs. If parallel loops you <em>ADD</em>. E.g. a + b. If nested loops you <em>multiply</em>. E.g. a * b</p>

<p>4) <strong>Drop Non-Dominants</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printNumsThenAllPairSums</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">{</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">these are the numbers:</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">numbers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">number</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">number</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">and these are their sums:</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">numbers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">firstNumber</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">numbers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">secondNumber</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">firstNumber</span> <span class="o">+</span> <span class="nx">secondNumber</span><span class="p">);</span>
   <span class="p">});</span>
<span class="p">});</span>
<span class="p">}</span>

<span class="nx">printNumsThenAllPairSums</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
</code></pre></div></div>

<ul>
  <li>This could be as <code class="highlighter-rouge">O(n + n^2)</code>. But you need to drop non-dominants. n^2 is more important since it is worst. So drop <code class="highlighter-rouge">n</code> and it will be as <code class="highlighter-rouge">O(n^2)</code>.</li>
  <li>Worry about the MOST important then drop the rest.</li>
  <li>Focus on dominant terms.</li>
</ul>

<h3 id="space-complexity-memory">Space Complexity (Memory)</h3>

<p>When program executes it will <strong>heap</strong> (store variables) or <strong>stack</strong> (keep track of function calls).
You also look at total size and see how much memory is being used.</p>

<p>What adds space complexity?</p>
<ul>
  <li>Adding variables</li>
  <li>Adding data structures</li>
  <li>Function calls and allocations</li>
</ul>

<p>Space complexity refers to additional space. Example:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">function</span> <span class="nx">boooo</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">booooo</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Space complexity O(n)</span>
<span class="kd">function</span> <span class="nx">arrayOfHiNTimes</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">hiArray</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">hiArray</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hi</span><span class="dl">'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">hiArray</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Often it is a tradeoff of optimizing code it <em>will increase space complexity</em>.</p>

<h2 id="final-notes">Final Notes</h2>

<p>Sometimes optimizing might not be the right choice at beginning. Get the problem solved first. So you need to get the right balance between run time, space and readability. BigO is crucial for bigger apps but work on it, it will make you a better engineer. Focus on O(1), O(n) and O(n^2) then expand into others.</p>

<p>In interviews most of time youâ€™ll do O(n) and O(1)!</p>

<h2 id="read-more">Read More</h2>

<ul>
  <li><a href="https://www.digitalocean.com/community/tutorials/js-big-o-notation"><strong>Understanding Big O Notation via JavaScript</strong></a></li>
  <li><a href="https://www.udemy.com/course/master-the-coding-interview-data-structures-algorithms/"><strong>Master The Coding Interview</strong></a></li>
  <li><a href="https://dev.to/b0nbon1/understanding-big-o-notation-with-javascript-25mc"><strong>Understanding Big-O Notation With JavaScript</strong></a></li>
</ul>
:ET